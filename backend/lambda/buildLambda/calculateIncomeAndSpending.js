"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateIncomeAndSpending = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const Entities_1 = require("./queries/Entities");
const Encryption_1 = require("./queries/Encryption");
const Item_1 = require("./mappers/Item");
const API_1 = require("./API");
const Transactions_1 = require("./mappers/Transactions");
const Summaries_1 = require("./queries/Summaries");
const client = new client_dynamodb_1.DynamoDBClient({ region: 'ca-central-1' });
function aggregateSpendingByCategory(transactions) {
    const MS_IN_A_DAY = 1000 * 60 * 60 * 24;
    // Initialize accumulators
    const dailySpendingMap = {};
    const weeklySpending = {};
    const monthlySpending = {};
    // Step 1: Sum amounts per category by day
    for (const transaction of transactions) {
        if (transaction.amount && transaction.date) {
            const amount = parseFloat(transaction.amount);
            const date = new Date(transaction.date);
            const dateKey = date.toISOString().split('T')[0]; // Format date as YYYY-MM-DD
            // Only consider transactions that are spending, not income or transfers
            let category;
            if ((transaction.personal_finance_category?.detailed).S in API_1.HighLevelTransactionCategory) {
                category = (transaction.personal_finance_category?.detailed).S ?? '';
            }
            else {
                category = (transaction.personal_finance_category?.primary).S ?? '';
            }
            if (category) {
                // Initialize daily spending map for the date if not present
                if (!dailySpendingMap[dateKey]) {
                    dailySpendingMap[dateKey] = {};
                }
                // Aggregate amounts for each category in daily, weekly, and monthly maps
                dailySpendingMap[dateKey][category] = (dailySpendingMap[dateKey][category] || 0) + Math.abs(amount);
                weeklySpending[category] = (weeklySpending[category] || 0) + Math.abs(amount);
                monthlySpending[category] = (monthlySpending[category] || 0) + Math.abs(amount);
            }
        }
    }
    // Convert daily spending map to an array of DailySpendingSummary
    const dailySpendingSummaries = Object.entries(dailySpendingMap).map(([date, spending]) => ({
        date,
        spending,
    }));
    // Step 2: Calculate date range for averages
    const transactionDates = Object.keys(dailySpendingMap).map((date) => new Date(date));
    if (transactionDates.length === 0) {
        throw new Error('No valid transactions found to aggregate.');
    }
    const minDate = new Date(Math.min(...transactionDates.map((date) => date.getTime())));
    const maxDate = new Date(Math.max(...transactionDates.map((date) => date.getTime())));
    const durationInDays = (maxDate.getTime() - minDate.getTime()) / MS_IN_A_DAY;
    // Step 3: Calculate weekly and monthly averages
    for (const category of Object.keys(weeklySpending)) {
        if (weeklySpending[category])
            weeklySpending[category] /= durationInDays / 7;
        if (monthlySpending[category])
            monthlySpending[category] /= durationInDays / 30;
    }
    return {
        daily_spending: dailySpendingSummaries,
        weekly_spending: weeklySpending,
        monthly_spending: monthlySpending,
    };
}
function groupTransactionsByMonth(transactions) {
    const monthlyAggregates = {};
    const transactionsByMonth = transactions.reduce((acc, transaction) => {
        if (transaction.date) {
            const date = new Date(transaction.date);
            const monthYear = `${date.getFullYear()}-${date.getMonth() + 1}`;
            if (!acc[monthYear]) {
                acc[monthYear] = [];
            }
            acc[monthYear].push(transaction);
        }
        return acc;
    }, {});
    for (const [monthYear, monthTransactions] of Object.entries(transactionsByMonth)) {
        monthlyAggregates[monthYear] = aggregateSpendingByCategory(monthTransactions);
    }
    return monthlyAggregates;
}
function getEarliestFirstOfMonthWithin90Days(createdAt) {
    return new Date(new Date().getTime() - 1000 * 3600 * 24 * 365);
}
const calculateIncomeAndSpending = async () => {
    // TODO: Add logic to handle last calculated complete month and start from then
    const items = (await (0, Encryption_1.decryptItemsInBatches)((await client.send((0, Entities_1.GetItems)()))?.Items ?? [])).map(Item_1.mapDdbResponseToItem);
    /** TODO: Just add created at to the item? */
    const encryptedUserItemRecord = await Promise.all(items.map(async (el) => await client.send((0, Entities_1.GetUser)(el.sk || ''))));
    const decryptedUserItemRecord = (await (0, Encryption_1.decryptItemsInBatches)(encryptedUserItemRecord.flatMap((output) => output.Items ?? [])))
        .map(Item_1.mapDdbResponseToItem)
        .filter((item) => {
        console.info('Processing', item);
        return item.pk && item.created_at;
    });
    /** Go through users and aggregate transactions */
    await processUsersInBatches(decryptedUserItemRecord);
};
exports.calculateIncomeAndSpending = calculateIncomeAndSpending;
function chunkArray(array, chunkSize) {
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize) {
        chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
}
async function processUsersInBatches(decryptedUserItemRecord) {
    const userBatches = chunkArray(decryptedUserItemRecord, 100);
    const now = new Date(); // Get the current date and time
    for (const batch of userBatches) {
        await Promise.all(batch.map(async (item) => {
            const startDay = getEarliestFirstOfMonthWithin90Days(new Date(item?.created_at ?? 0));
            console.info(startDay);
            const encryptedTransactions = await client.send((0, Entities_1.GetEntities)({
                pk: item.pk ?? '',
                dateRange: {
                    startDay: {
                        day: startDay.getDate() + 1,
                        month: startDay.getMonth() + 1,
                        year: startDay.getFullYear(),
                    },
                    endDay: {
                        day: now.getDate() + 1,
                        month: now.getMonth() + 1,
                        year: now.getFullYear(),
                    },
                    hasNoTimeConstraint: false,
                },
                username: '',
                id: '',
                entityName: 'TRANSACTION',
            }));
            const decryptedTransactions = (await (0, Encryption_1.decryptItemsInBatches)(encryptedTransactions.Items ?? [])).map(Transactions_1.mapDynamoDBToTransaction);
            console.info(decryptedTransactions);
            const aggregates = groupTransactionsByMonth(decryptedTransactions);
            await (0, Summaries_1.uploadSpendingSummaries)(item.pk ?? '', Object.entries(aggregates).flatMap((el) => el[1].daily_spending), aggregates);
        }));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsY3VsYXRlSW5jb21lQW5kU3BlbmRpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY2FsY3VsYXRlSW5jb21lQW5kU3BlbmRpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsOERBQXlFO0FBQ3pFLGlEQUFtRTtBQUNuRSxxREFBNEQ7QUFDNUQseUNBQXFEO0FBQ3JELCtCQUF1RTtBQUN2RSx5REFBaUU7QUFDakUsbURBQTZEO0FBRzdELE1BQU0sTUFBTSxHQUFHLElBQUksZ0NBQWMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFBO0FBaUI3RCxTQUFTLDJCQUEyQixDQUFDLFlBQTJCO0lBQzVELE1BQU0sV0FBVyxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQTtJQUV2QywwQkFBMEI7SUFDMUIsTUFBTSxnQkFBZ0IsR0FBZ0YsRUFBRSxDQUFBO0lBQ3hHLE1BQU0sY0FBYyxHQUFHLEVBQTZELENBQUE7SUFDcEYsTUFBTSxlQUFlLEdBQUcsRUFBNkQsQ0FBQTtJQUVyRiwwQ0FBMEM7SUFDMUMsS0FBSyxNQUFNLFdBQVcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUNyQyxJQUFJLFdBQVcsQ0FBQyxNQUFNLElBQUksV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3pDLE1BQU0sTUFBTSxHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUE7WUFDN0MsTUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFBO1lBQ3ZDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUEsQ0FBQyw0QkFBNEI7WUFFN0Usd0VBQXdFO1lBQ3hFLElBQUksUUFBc0MsQ0FBQTtZQUMxQyxJQUFJLENBQUMsV0FBVyxDQUFDLHlCQUF5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QVEsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDO3dCQUMzQixLQUFLLEVBQUUsUUFBUSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUM7d0JBQzlCLElBQUksRUFBRSxRQUFRLENBQUMsV0FBVyxFQUFFO3FCQUMvQjtvQkFDRCxNQUFNLEVBQUU7d0JBQ0osR0FBRyxFQUFFLEdBQUcsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDO3dCQUN0QixLQUFLLEVBQUUsR0FBRyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUM7d0JBQ3pCLElBQUksRUFBRSxHQUFHLENBQUMsV0FBVyxFQUFFO3FCQUMxQjtvQkFDRCxtQkFBbUIsRUFBRSxLQUFLO2lCQUM3QjtnQkFDRCxRQUFRLEVBQUUsRUFBRTtnQkFDWixFQUFFLEVBQUUsRUFBRTtnQkFDTixVQUFVLEVBQUUsYUFBYTthQUM1QixDQUFDLENBQ0wsQ0FBQTtZQUVELE1BQU0scUJBQXFCLEdBQUcsQ0FBQyxNQUFNLElBQUEsa0NBQXFCLEVBQUMscUJBQXFCLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUM5Rix1Q0FBd0IsQ0FDM0IsQ0FBQTtZQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQTtZQUNuQyxNQUFNLFVBQVUsR0FBRyx3QkFBd0IsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFBO1lBRWxFLE1BQU0sSUFBQSxtQ0FBdUIsRUFDekIsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQ2IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsRUFDaEUsVUFBVSxDQUNiLENBQUE7UUFDTCxDQUFDLENBQUMsQ0FDTCxDQUFBO0lBQ0wsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEeW5hbW9EQkNsaWVudCwgUHV0SXRlbUNvbW1hbmQgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtZHluYW1vZGInXG5pbXBvcnQgeyBHZXRFbnRpdGllcywgR2V0SXRlbXMsIEdldFVzZXIgfSBmcm9tICcuL3F1ZXJpZXMvRW50aXRpZXMnXG5pbXBvcnQgeyBkZWNyeXB0SXRlbXNJbkJhdGNoZXMgfSBmcm9tICcuL3F1ZXJpZXMvRW5jcnlwdGlvbidcbmltcG9ydCB7IG1hcERkYlJlc3BvbnNlVG9JdGVtIH0gZnJvbSAnLi9tYXBwZXJzL0l0ZW0nXG5pbXBvcnQgeyBIaWdoTGV2ZWxUcmFuc2FjdGlvbkNhdGVnb3J5LCBJdGVtLCBUcmFuc2FjdGlvbiB9IGZyb20gJy4vQVBJJ1xuaW1wb3J0IHsgbWFwRHluYW1vREJUb1RyYW5zYWN0aW9uIH0gZnJvbSAnLi9tYXBwZXJzL1RyYW5zYWN0aW9ucydcbmltcG9ydCB7IHVwbG9hZFNwZW5kaW5nU3VtbWFyaWVzIH0gZnJvbSAnLi9xdWVyaWVzL1N1bW1hcmllcydcbmltcG9ydCB7IGFueSB9IGZyb20gJ3pvZCdcblxuY29uc3QgY2xpZW50ID0gbmV3IER5bmFtb0RCQ2xpZW50KHsgcmVnaW9uOiAnY2EtY2VudHJhbC0xJyB9KVxuXG5leHBvcnQgdHlwZSBEYWlseVNwZW5kaW5nU3VtbWFyeSA9IHtcbiAgICBkYXRlOiBzdHJpbmdcbiAgICBzcGVuZGluZzogeyBbY2F0ZWdvcnkgaW4gSGlnaExldmVsVHJhbnNhY3Rpb25DYXRlZ29yeV0/OiBudW1iZXIgfVxufVxuXG5leHBvcnQgdHlwZSBBZ2dyZWdhdGVkU3BlbmRpbmcgPSB7XG4gICAgZGFpbHlfc3BlbmRpbmc6IERhaWx5U3BlbmRpbmdTdW1tYXJ5W11cbiAgICB3ZWVrbHlfc3BlbmRpbmc6IHsgW2NhdGVnb3J5IGluIEhpZ2hMZXZlbFRyYW5zYWN0aW9uQ2F0ZWdvcnldPzogbnVtYmVyIH1cbiAgICBtb250aGx5X3NwZW5kaW5nOiB7IFtjYXRlZ29yeSBpbiBIaWdoTGV2ZWxUcmFuc2FjdGlvbkNhdGVnb3J5XT86IG51bWJlciB9XG59XG5cbnR5cGUgTW9udGhseVNwZW5kaW5nQWdncmVnYXRlcyA9IHtcbiAgICBbbW9udGhZZWFyOiBzdHJpbmddOiBBZ2dyZWdhdGVkU3BlbmRpbmdcbn1cblxuZnVuY3Rpb24gYWdncmVnYXRlU3BlbmRpbmdCeUNhdGVnb3J5KHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXSk6IEFnZ3JlZ2F0ZWRTcGVuZGluZyB7XG4gICAgY29uc3QgTVNfSU5fQV9EQVkgPSAxMDAwICogNjAgKiA2MCAqIDI0XG5cbiAgICAvLyBJbml0aWFsaXplIGFjY3VtdWxhdG9yc1xuICAgIGNvbnN0IGRhaWx5U3BlbmRpbmdNYXA6IHsgW2RhdGU6IHN0cmluZ106IHsgW2NhdGVnb3J5IGluIEhpZ2hMZXZlbFRyYW5zYWN0aW9uQ2F0ZWdvcnldPzogbnVtYmVyIH0gfSA9IHt9XG4gICAgY29uc3Qgd2Vla2x5U3BlbmRpbmcgPSB7fSBhcyB7IFtjYXRlZ29yeSBpbiBIaWdoTGV2ZWxUcmFuc2FjdGlvbkNhdGVnb3J5XT86IG51bWJlciB9XG4gICAgY29uc3QgbW9udGhseVNwZW5kaW5nID0ge30gYXMgeyBbY2F0ZWdvcnkgaW4gSGlnaExldmVsVHJhbnNhY3Rpb25DYXRlZ29yeV0/OiBudW1iZXIgfVxuXG4gICAgLy8gU3RlcCAxOiBTdW0gYW1vdW50cyBwZXIgY2F0ZWdvcnkgYnkgZGF5XG4gICAgZm9yIChjb25zdCB0cmFuc2FjdGlvbiBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFtb3VudCAmJiB0cmFuc2FjdGlvbi5kYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBhbW91bnQgPSBwYXJzZUZsb2F0KHRyYW5zYWN0aW9uLmFtb3VudClcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0cmFuc2FjdGlvbi5kYXRlKVxuICAgICAgICAgICAgY29uc3QgZGF0ZUtleSA9IGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdIC8vIEZvcm1hdCBkYXRlIGFzIFlZWVktTU0tRERcblxuICAgICAgICAgICAgLy8gT25seSBjb25zaWRlciB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgc3BlbmRpbmcsIG5vdCBpbmNvbWUgb3IgdHJhbnNmZXJzXG4gICAgICAgICAgICBsZXQgY2F0ZWdvcnk6IEhpZ2hMZXZlbFRyYW5zYWN0aW9uQ2F0ZWdvcnlcbiAgICAgICAgICAgIGlmICgodHJhbnNhY3Rpb24ucGVyc29uYWxfZmluYW5jZV9jYXRlZ29yeT8uZGV0YWlsZWQgYXMgYW55KS5TIGluIEhpZ2hMZXZlbFRyYW5zYWN0aW9uQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeSA9ICh0cmFuc2FjdGlvbi5wZXJzb25hbF9maW5hbmNlX2NhdGVnb3J5Py5kZXRhaWxlZCBhcyBhbnkpLlMgPz8gJydcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnkgPSAodHJhbnNhY3Rpb24ucGVyc29uYWxfZmluYW5jZV9jYXRlZ29yeT8ucHJpbWFyeSBhcyBhbnkpLlMgPz8gJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgZGFpbHkgc3BlbmRpbmcgbWFwIGZvciB0aGUgZGF0ZSBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgIGlmICghZGFpbHlTcGVuZGluZ01hcFtkYXRlS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBkYWlseVNwZW5kaW5nTWFwW2RhdGVLZXldID0ge31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZ2dyZWdhdGUgYW1vdW50cyBmb3IgZWFjaCBjYXRlZ29yeSBpbiBkYWlseSwgd2Vla2x5LCBhbmQgbW9udGhseSBtYXBzXG4gICAgICAgICAgICAgICAgZGFpbHlTcGVuZGluZ01hcFtkYXRlS2V5XVtjYXRlZ29yeV0gPSAoZGFpbHlTcGVuZGluZ01hcFtkYXRlS2V5XVtjYXRlZ29yeV0gfHwgMCkgKyBNYXRoLmFicyhhbW91bnQpXG4gICAgICAgICAgICAgICAgd2Vla2x5U3BlbmRpbmdbY2F0ZWdvcnldID0gKHdlZWtseVNwZW5kaW5nW2NhdGVnb3J5XSB8fCAwKSArIE1hdGguYWJzKGFtb3VudClcbiAgICAgICAgICAgICAgICBtb250aGx5U3BlbmRpbmdbY2F0ZWdvcnldID0gKG1vbnRobHlTcGVuZGluZ1tjYXRlZ29yeV0gfHwgMCkgKyBNYXRoLmFicyhhbW91bnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGRhaWx5IHNwZW5kaW5nIG1hcCB0byBhbiBhcnJheSBvZiBEYWlseVNwZW5kaW5nU3VtbWFyeVxuICAgIGNvbnN0IGRhaWx5U3BlbmRpbmdTdW1tYXJpZXM6IERhaWx5U3BlbmRpbmdTdW1tYXJ5W10gPSBPYmplY3QuZW50cmllcyhkYWlseVNwZW5kaW5nTWFwKS5tYXAoKFtkYXRlLCBzcGVuZGluZ10pID0+ICh7XG4gICAgICAgIGRhdGUsXG4gICAgICAgIHNwZW5kaW5nLFxuICAgIH0pKVxuXG4gICAgLy8gU3RlcCAyOiBDYWxjdWxhdGUgZGF0ZSByYW5nZSBmb3IgYXZlcmFnZXNcbiAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGVzID0gT2JqZWN0LmtleXMoZGFpbHlTcGVuZGluZ01hcCkubWFwKChkYXRlKSA9PiBuZXcgRGF0ZShkYXRlKSlcbiAgICBpZiAodHJhbnNhY3Rpb25EYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCB0cmFuc2FjdGlvbnMgZm91bmQgdG8gYWdncmVnYXRlLicpXG4gICAgfVxuXG4gICAgY29uc3QgbWluRGF0ZSA9IG5ldyBEYXRlKE1hdGgubWluKC4uLnRyYW5zYWN0aW9uRGF0ZXMubWFwKChkYXRlKSA9PiBkYXRlLmdldFRpbWUoKSkpKVxuICAgIGNvbnN0IG1heERhdGUgPSBuZXcgRGF0ZShNYXRoLm1heCguLi50cmFuc2FjdGlvbkRhdGVzLm1hcCgoZGF0ZSkgPT4gZGF0ZS5nZXRUaW1lKCkpKSlcbiAgICBjb25zdCBkdXJhdGlvbkluRGF5cyA9IChtYXhEYXRlLmdldFRpbWUoKSAtIG1pbkRhdGUuZ2V0VGltZSgpKSAvIE1TX0lOX0FfREFZXG5cbiAgICAvLyBTdGVwIDM6IENhbGN1bGF0ZSB3ZWVrbHkgYW5kIG1vbnRobHkgYXZlcmFnZXNcbiAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIE9iamVjdC5rZXlzKHdlZWtseVNwZW5kaW5nKSBhcyBIaWdoTGV2ZWxUcmFuc2FjdGlvbkNhdGVnb3J5W10pIHtcbiAgICAgICAgaWYgKHdlZWtseVNwZW5kaW5nW2NhdGVnb3J5XSkgd2Vla2x5U3BlbmRpbmdbY2F0ZWdvcnldISAvPSBkdXJhdGlvbkluRGF5cyAvIDdcbiAgICAgICAgaWYgKG1vbnRobHlTcGVuZGluZ1tjYXRlZ29yeV0pIG1vbnRobHlTcGVuZGluZ1tjYXRlZ29yeV0hIC89IGR1cmF0aW9uSW5EYXlzIC8gMzBcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkYWlseV9zcGVuZGluZzogZGFpbHlTcGVuZGluZ1N1bW1hcmllcyxcbiAgICAgICAgd2Vla2x5X3NwZW5kaW5nOiB3ZWVrbHlTcGVuZGluZyxcbiAgICAgICAgbW9udGhseV9zcGVuZGluZzogbW9udGhseVNwZW5kaW5nLFxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ3JvdXBUcmFuc2FjdGlvbnNCeU1vbnRoKHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXSk6IE1vbnRobHlTcGVuZGluZ0FnZ3JlZ2F0ZXMge1xuICAgIGNvbnN0IG1vbnRobHlBZ2dyZWdhdGVzOiBNb250aGx5U3BlbmRpbmdBZ2dyZWdhdGVzID0ge31cblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uc0J5TW9udGg6IHsgW21vbnRoWWVhcjogc3RyaW5nXTogVHJhbnNhY3Rpb25bXSB9ID0gdHJhbnNhY3Rpb25zLnJlZHVjZSgoYWNjLCB0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRyYW5zYWN0aW9uLmRhdGUpXG4gICAgICAgICAgICBjb25zdCBtb250aFllYXIgPSBgJHtkYXRlLmdldEZ1bGxZZWFyKCl9LSR7ZGF0ZS5nZXRNb250aCgpICsgMX1gXG5cbiAgICAgICAgICAgIGlmICghYWNjW21vbnRoWWVhcl0pIHtcbiAgICAgICAgICAgICAgICBhY2NbbW9udGhZZWFyXSA9IFtdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFjY1ttb250aFllYXJdLnB1c2godHJhbnNhY3Rpb24pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIHt9IGFzIHsgW21vbnRoWWVhcjogc3RyaW5nXTogVHJhbnNhY3Rpb25bXSB9KVxuXG4gICAgZm9yIChjb25zdCBbbW9udGhZZWFyLCBtb250aFRyYW5zYWN0aW9uc10gb2YgT2JqZWN0LmVudHJpZXModHJhbnNhY3Rpb25zQnlNb250aCkpIHtcbiAgICAgICAgbW9udGhseUFnZ3JlZ2F0ZXNbbW9udGhZZWFyXSA9IGFnZ3JlZ2F0ZVNwZW5kaW5nQnlDYXRlZ29yeShtb250aFRyYW5zYWN0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gbW9udGhseUFnZ3JlZ2F0ZXNcbn1cbmZ1bmN0aW9uIGdldEVhcmxpZXN0Rmlyc3RPZk1vbnRoV2l0aGluOTBEYXlzKGNyZWF0ZWRBdDogRGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIDEwMDAgKiAzNjAwICogMjQgKiAzNjUpXG59XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVJbmNvbWVBbmRTcGVuZGluZyA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBUT0RPOiBBZGQgbG9naWMgdG8gaGFuZGxlIGxhc3QgY2FsY3VsYXRlZCBjb21wbGV0ZSBtb250aCBhbmQgc3RhcnQgZnJvbSB0aGVuXG4gICAgY29uc3QgaXRlbXMgPSAoYXdhaXQgZGVjcnlwdEl0ZW1zSW5CYXRjaGVzKChhd2FpdCBjbGllbnQuc2VuZChHZXRJdGVtcygpKSk/Lkl0ZW1zID8/IFtdKSkubWFwKG1hcERkYlJlc3BvbnNlVG9JdGVtKVxuICAgIC8qKiBUT0RPOiBKdXN0IGFkZCBjcmVhdGVkIGF0IHRvIHRoZSBpdGVtPyAqL1xuICAgIGNvbnN0IGVuY3J5cHRlZFVzZXJJdGVtUmVjb3JkID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIChlbCkgPT4gYXdhaXQgY2xpZW50LnNlbmQoR2V0VXNlcihlbC5zayB8fCAnJykpKSlcbiAgICBjb25zdCBkZWNyeXB0ZWRVc2VySXRlbVJlY29yZCA9IChcbiAgICAgICAgYXdhaXQgZGVjcnlwdEl0ZW1zSW5CYXRjaGVzKGVuY3J5cHRlZFVzZXJJdGVtUmVjb3JkLmZsYXRNYXAoKG91dHB1dCkgPT4gb3V0cHV0Lkl0ZW1zID8/IFtdKSlcbiAgICApXG4gICAgICAgIC5tYXAobWFwRGRiUmVzcG9uc2VUb0l0ZW0pXG4gICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnUHJvY2Vzc2luZycsIGl0ZW0pXG4gICAgICAgICAgICByZXR1cm4gaXRlbS5wayAmJiBpdGVtLmNyZWF0ZWRfYXRcbiAgICAgICAgfSlcbiAgICAvKiogR28gdGhyb3VnaCB1c2VycyBhbmQgYWdncmVnYXRlIHRyYW5zYWN0aW9ucyAqL1xuICAgIGF3YWl0IHByb2Nlc3NVc2Vyc0luQmF0Y2hlcyhkZWNyeXB0ZWRVc2VySXRlbVJlY29yZClcbn1cblxuZnVuY3Rpb24gY2h1bmtBcnJheTxUPihhcnJheTogVFtdLCBjaHVua1NpemU6IG51bWJlcik6IFRbXVtdIHtcbiAgICBjb25zdCBjaHVua3M6IFRbXVtdID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICAgICAgY2h1bmtzLnB1c2goYXJyYXkuc2xpY2UoaSwgaSArIGNodW5rU2l6ZSkpXG4gICAgfVxuICAgIHJldHVybiBjaHVua3Ncbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1VzZXJzSW5CYXRjaGVzKGRlY3J5cHRlZFVzZXJJdGVtUmVjb3JkOiBJdGVtW10pIHtcbiAgICBjb25zdCB1c2VyQmF0Y2hlcyA9IGNodW5rQXJyYXkoZGVjcnlwdGVkVXNlckl0ZW1SZWNvcmQsIDEwMClcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpIC8vIEdldCB0aGUgY3VycmVudCBkYXRlIGFuZCB0aW1lXG5cbiAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHVzZXJCYXRjaGVzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgYmF0Y2gubWFwKGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnREYXkgPSBnZXRFYXJsaWVzdEZpcnN0T2ZNb250aFdpdGhpbjkwRGF5cyhuZXcgRGF0ZShpdGVtPy5jcmVhdGVkX2F0ID8/IDApKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhzdGFydERheSlcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWRUcmFuc2FjdGlvbnMgPSBhd2FpdCBjbGllbnQuc2VuZChcbiAgICAgICAgICAgICAgICAgICAgR2V0RW50aXRpZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGs6IGl0ZW0ucGsgPz8gJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlUmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXk6IHN0YXJ0RGF5LmdldERhdGUoKSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoOiBzdGFydERheS5nZXRNb250aCgpICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhcjogc3RhcnREYXkuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXk6IG5vdy5nZXREYXRlKCkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aDogbm93LmdldE1vbnRoKCkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ZWFyOiBub3cuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc05vVGltZUNvbnN0cmFpbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eU5hbWU6ICdUUkFOU0FDVElPTicsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkVHJhbnNhY3Rpb25zID0gKGF3YWl0IGRlY3J5cHRJdGVtc0luQmF0Y2hlcyhlbmNyeXB0ZWRUcmFuc2FjdGlvbnMuSXRlbXMgPz8gW10pKS5tYXAoXG4gICAgICAgICAgICAgICAgICAgIG1hcER5bmFtb0RCVG9UcmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oZGVjcnlwdGVkVHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgICAgIGNvbnN0IGFnZ3JlZ2F0ZXMgPSBncm91cFRyYW5zYWN0aW9uc0J5TW9udGgoZGVjcnlwdGVkVHJhbnNhY3Rpb25zKVxuXG4gICAgICAgICAgICAgICAgYXdhaXQgdXBsb2FkU3BlbmRpbmdTdW1tYXJpZXMoXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucGsgPz8gJycsXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGFnZ3JlZ2F0ZXMpLmZsYXRNYXAoKGVsKSA9PiBlbFsxXS5kYWlseV9zcGVuZGluZyksXG4gICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZXNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgfVxufVxuIl19